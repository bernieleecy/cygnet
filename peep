#!/usr/bin/env python3

import os
import sys
import subprocess
import asyncio
from time import time, sleep
from threading import Thread
from copy import deepcopy
from pathlib import Path
from enum import Enum
from locale import getpreferredencoding
from functools import wraps

import yaml
import prompt_toolkit as pt
from crossref.restful import Works, Etiquette


class _g():
    # Storage of global variables.
    version_number = "0.1"
    my_etiquette = Etiquette('PeepLaTeX',
                             version_number,
                             'https://github.com/yongrenjie',
                             'yongrenjie@gmail.com')
    # List of dictionaries, each containing a single article.
    articleList = []
    # pathlib.Path object pointing to the current database.
    currentPath = None
    # Number of changes made to articleList that haven't been autosaved.
    changes = 0
    # Debugging mode on/off
    debug = True
    # Colours for the prompt
    # Check for Dark Mode (OS X)
    darkmode = True
    if sys.platform == "darwin":
        try:
            subprocess.run(["defaults", "read", "-g",
                            "AppleInterfaceStyle", "2>/dev/null"], check=True)
        except subprocess.CalledProcessError:
            darkmode = False
    pink = "#f589d1" if darkmode else "#8629ab"
    green = "#17cf48" if darkmode else "#2a731f"


class _exitCode(Enum):
    SUCCESS = 0
    FAILURE = 1
    pass


def timedeco(fn):
    """
    Decorator which prints time elapsed for a function call.
    """
    @wraps(fn)
    def timer(*args, **kwargs):
        now = time()
        rval = fn(*args, **kwargs)
        _debug("{}: time elapsed: {:.3f} ms".format(fn.__name__,
                                                   (time() - now) * 1000))
        return rval
    return timer


class peepPrompt():
    style = pt.styles.Style.from_dict({
        "prompt": "{} italic".format(_g.pink),
        ""      : "{}".format(_g.green),
    })
    message = [("class:prompt", "peep > ")]
    session = pt.PromptSession()

    intro = "/------------------------------------------------------------\\" "\n"\
           f"| PeepLaTeX v{_g.version_number:<23}                         |"  "\n"\
            "| Common commands:                                           |"  "\n"\
            "| ----------------                                           |"  "\n"\
            "| r - read database     l - list papers     o - open a paper |"  "\n"\
            "| c - get a citation    h - help            q - quit         |"  "\n"\
            "\\------------------------------------------------------------/"

    async def loop(self):
        print(self.intro)
        with pt.patch_stdout.patch_stdout():
            while True:
                try:
                    line = await self.session.prompt_async(self.message,
                                                           style=self.style)
                except KeyboardInterrupt:
                    continue
                except EOFError:
                    break
                else:
                    x = line.split()
                    if not x:
                        continue
                    else:
                        cmd, args = x[0], x[1:]

                    if cmd in ["q", "quit"]:            # QUIT
                        break
                    elif cmd in ["o", "open"]:          # OPEN
                        openRef(args)
                    elif cmd in ["w", "write"]:         # WRITE
                        write(args)
                    elif cmd in ["l", "ls", "list"]:    # LIST
                        listArticles()
                    elif cmd in ["r", "read"]:          # READ
                        read(args)
                    elif cmd in ["h", "help"]:          # HELP
                        print(self.intro)
                    else:                               # unknown
                        _error("command '{}' not recognised".format(cmd))

                    # Need a tiny sleep to paper over a weird bug.
                    # Try removing this and spamming 'l' before quitting
                    #  to see the bug.
                    # There WILL be bugs if the time taken to print any
                    #  output (e.g. 'l' with large databases) exceeds
                    #  this sleep. With 3 references, printing takes a
                    #  fraction of a millisecond. With 300 references
                    #  it takes about 60 ms.
                    await asyncio.sleep(0.1)   # 100 ms.
        return


#### Key functions
@timedeco
def read(args=Path.cwd(), output=None):
    """
    Reads a YAML file into the list of dictionaries _g.articleList.

    Accepts a string, pathlib.Path object, or a list/tuple containing
     a string or Path object as the first item.

    If the argument is a directory, then read() attempts to read from the
     file db.yaml inside that directory.

    Defaults to Path.cwd().
    """
    # Argument parsing
    if isinstance(args, (list, tuple)):
        try:
            args = args[0]
        except IndexError:   # empty list or tuple
            args = Path.cwd()
    try:
        p = Path(args)
    except TypeError:   # not castable
        return _error("invalid argument '{}' provided to read()".format(args))
    # If it points to an existing directory, load db.yaml from there
    if p.is_dir() and p.exists():
        p = p / "db.yaml"
    # Expand tildes and relative paths
    fname = p.expanduser().resolve()

    # Check if the yaml file exists
    if not fname.exists():
        return _error("file {} not found".format(fname))

    # Read in the yaml file
    try:
        with open(fname, "r") as fp:
            if output != "silent":
                print("reading library {}... ".format(fname))
            _g.articleList = list(yaml.safe_load_all(fp))
            if output != "silent":
                print("read done")
    except FileNotFoundError:  # seems redundant, but ok
        return _error("file {} not found".format(fname))
    else:
        _g.currentPath = fname
        return _exitCode.SUCCESS


@timedeco
def write(args=None, output=None):
    """
    Writes the list of dictionaries _g.articleList to a YAML file.

    Accepts a string, pathlib.Path object, or a list/tuple containing
     a string or Path object as the first item.
    Defaults to _g.currentPath.
    """
    ### Argument parsing
    # Convert to a pathlib.Path object regardless of the input
    if isinstance(args, (list, tuple)):
        try:
            args = args[0]
        except IndexError:   # empty list or tuple
            args = _g.currentPath
    if args is None:
        args = _g.currentPath
    try:
        fname = Path(args)
    except TypeError:  # not castable
        return _error("invalid argument '{}' provided to write()".format(args))

    # Determine output location
    if fname.is_dir() and fname.exists():
        fname = fname / "db.yaml"

    # Write to the file
    try:
        with open(fname, "w") as fp:
            if output != "silent":
                print("writing library to {}... ".format(fname))
            yaml.dump_all(_g.articleList, fp)
            if output != "silent":
                print("write done")
    except FileNotFoundError:
        return _error("directory {} does not exist".format(fname.parent))

    return _exitCode.SUCCESS


@timedeco
def listArticles(articles=None, type="long"):
    """
    Print prettified output of a given list of articles. Defaults to the entire
     list of articles _g.articleList.

    Accepts an additional parameter to control how many articles are printed.
     type="long": prints every article.
     type="short": prints first 2 and last 2.
    """
    # Exit if an empty list is provided
    if articles == []:
        print("no articles found")
        return
    # Make a copy first...
    l = deepcopy(articles) if articles is not None else deepcopy(_g.articleList)

    # Get field sizes
    layout_str = "{0:<{1}}{2:{3}}{4:<{5}}{6:{7}}{8:{9}}"
    fss = _getFS(l)
    number_fs, author_fs, year_fs, journal_fs, title_fs = fss

    # Print header
    _printListHead(layout_str, fss)

    # Print all article contents
    if len(l) <= 4 or type == "long":
        for i, a in enumerate(l, start=1):
            _listOneArticle(i, a, layout_str, fss)
        return _exitCode.SUCCESS
    elif type == "short":
        n = len(l)
        _listOneArticle(1, l[0], layout_str, fss)
        _listOneArticle(2, l[1], layout_str, fss)
        _printDots(layout_str, fss)
        _listOneArticle(n - 1, l[n - 2], layout_str, fss)
        _listOneArticle(n, l[n - 1], layout_str, fss)
        return _exitCode.SUCCESS
    else:
        raise RuntimeError("ARGHH!")


@timedeco
def openRef(argls):
    """
    Opens one or more references, in the form of PDF, SI, or Web.

    Takes a list of arguments.
    """
    # Preprocess argls, converting ["1", "2", "3", "p"] -> ["1,2,3,", "p"]
    argstr = ",".join(argls)
    # Accept long forms
    argstr = argstr.replace("pdf","p").replace("si","s").replace("web","w")
    # Find the first character in argstr that isn't [0-9,-]
    x = next((i for i, c in enumerate(argstr) if c not in "1234567890,-"), len(argstr))
    # Then repackage them
    argRefno = argstr[:x].rstrip(",")
    argFormat = argstr[x:].replace(",","").strip()

    # Parse reference number(s)
    try:
        refnos = _parseRefNo(argRefno)
    except IndexError:
        return _error("no reference number given")
    else:
        # Check the returned value
        ls = len(_g.articleList)
        if refnos is None or any(r > ls for r in refnos):
            return _error("invalid reference number(s) '{}' given".format(argRefno))
    # Parse format(s)
    if argFormat == "":
        formats = ['p']  # if no format specified, assume pdf
    else:
        formats = list(argFormat)
        # Check for invalid formats
        if any([i not in list("psw") for i in formats]):
            return _error("invalid format(s) '{}' given".format(argFormat))

    # Open the references
    # generator object
    rfs = ((r, f) for r in refnos for f in formats)
    # open(1) is really fast, so it doesn't seem like this could be a problem unless we
    #  are opening tons and tons of references. But if it does then we may want to use
    #  some concurrency methods.
    for rf in rfs:
        _openDOIType(*rf)


#### Internal tools for error reporting
def _error(msg):
    """
    Generic error printer.
    """
    print("error: {}".format(msg))
    return _exitCode.FAILURE


def _debug(msg):
    if _g.debug is True:
        print(msg)


#### Internal tools for list printing
def _printListHead(layout_str, fss):
    """
    Print the header.
    """
    # unpack field sizes
    number_fs, author_fs, year_fs, journal_fs, title_fs = fss
    # blank row
    print()
    # header row
    print(layout_str.format("#", number_fs,
                            "Authors", author_fs,
                            "Year", year_fs,
                            "Journal", journal_fs,
                            "Title & DOI", title_fs))
    # a horizontal line
    print("-" * (number_fs + author_fs + year_fs + journal_fs + title_fs))


def _listOneArticle(i, a, layout_str, fss):
    """
    Print one article.
     i          - the number in front.
     a          - the article
     layout_str - the format string.
     fss        - tuple of field sizes: (number, author, year, journal, title)
    """
    # unpack field sizes
    number_fs, author_fs, year_fs, journal_fs, title_fs = fss
    # generate volume info
    volinfo = _fmtVolInfo(a)
    # print the first round of information
    first_author = a["authors"].pop(0)
    print(layout_str.format(i, number_fs,
                            _fmtAuthor(first_author, style="display"), author_fs,
                            a["year"], year_fs,
                            a["journal_short"].replace(".",""), journal_fs,
                            a["title"][:title_fs], title_fs))
    # cut off the first author
    a["title"] = a["title"][title_fs:]
    # if there is still information to be printed, print it
    while any([a["authors"] != [],
               a["title"] != "",
               a["doi"] != "",
               volinfo != ""]):
        # get an author if there is one
        try:
            next_author = a["authors"].pop(0)
        except IndexError:
            next_author = ""
        # replace the title with the DOI if the title has been printed and DOI hasn't
        if a["title"] == "" and a["doi"] != "":
            a["title"] = a["doi"]
            a["doi"] = ""
        print(layout_str.format("", number_fs,
                                _fmtAuthor(next_author, style="display"), author_fs,
                                "", year_fs,
                                volinfo, journal_fs,
                                a["title"][:title_fs], title_fs))
        a["title"] = a["title"][title_fs:]
        volinfo = ""
    # empty line (for readability?)
    print()


def _printDots(layout_str, fss):
    """
    Prints dots.
    """
    # unpack field sizes
    number_fs, author_fs, year_fs, journal_fs, title_fs = fss
    # header row
    print(layout_str.format("...", number_fs,
                            "...", author_fs,
                            "...", year_fs,
                            "...", journal_fs,
                            "...", title_fs))
    print()


def _getFS(l):
    """
    Calculates appropriate field sizes for the list output.

    I tried caching this information in the article entry, but it makes virtually zero
     difference to the runtime even for a library of 1400 articles, and it adds extra time
     for reading/writing from/to disk (for reading in 1400 articles, the time taken increased
     from ca 2.4 -> 2.7 seconds).
    It's also a mess, because that means you'd have to remember to cache the information every
     time you change the metadata.
    Unfortunately you also can't use functools.lru_cache with this, because in general it will
     expect a dictionary as the argument, which isn't hashable.
    """
    spaces = 2
    number_fs = len(str(len(l))) + spaces
    author_fs = max(max(max(len(_fmtAuthor(auth, style="display")) for auth in art["authors"]) for art in l),
                    len("Authors")
                    ) + spaces
    year_fs = 4 + spaces
    journal_fs = max(max(len(art["journal_short"].replace(".","")) for art in l),
                     max(len(_fmtVolInfo(art)) for art in l),
                     len("Journal info")
                     ) + spaces
    # either use up the remaining space, or extend to the end of the longest title
    total_columns = os.get_terminal_size().columns
    title_fs = min(total_columns - number_fs - author_fs - year_fs - journal_fs,
                   max(len(a["title"]) for a in l))

    return (number_fs, author_fs, year_fs, journal_fs, title_fs)


def _fmtAuthor(author, style):
    """
    Prettify author names.
    """
    # Return empty string for any Falsy value
    if not author:
        return ""
    family_name = author["family"]
    given_names = author["given"]
    # Jonathan R. J. Yong -> JRJ Yong
    if style == "display":
        return "".join(n[0] for n in given_names.split()) + " " + author["family"]
    # Otherwise just return the name as a string
    else:
        return given_names + " " + family_name


def _fmtVolInfo(article):
    """
    Returns the string "vol (issue), page-page", or "vol, page-page" if
    no issue number is present.
    """
    if "issue" in article:
        return "{} ({}), {}".format(article["volume"],
                                    article["issue"],
                                    article["page"])
    else:
        return "{}, {}".format(article["volume"],
                               article["page"])


#### Internal tools for reference number parsing
def _parseRefNo(s):
    """
    Takes a string s and returns a list of int reference numbers.
    Returns None if any error is found.
     e.g. "1"      -> [1]
          "1-5"    -> [1, 2, 3, 4, 5]
          "1-4,43" -> [1, 2, 3, 4, 43]
    """
    s = s.split(",")
    t = []
    try:
        for i in s:
            if "-" in i:
                min, max = i.split("-")   # ValueError if too many entries
                if min >= max:
                    raise ValueError("you silly billy")
                for m in range(int(min), int(max) + 1):
                    t.append(m)
            else:
                t.append(int(i))          # ValueError if not castable to int
    except ValueError:
        return None
    else:
        return t


#### Internal tool for opening PDFs / DOI URLs
def _openDOIType(refno, format):
    # Get the doi
    try:
        doi = _g.articleList[refno - 1]["doi"]
    except IndexError:
        raise RuntimeError("AGH!!! _openDOIType() got an argument it shouldn't have!")

    # Get the link to the pdf / website
    if format == 'p':
        fname = _g.currentPath.parent / "pdf" / "{}.pdf".format(doi).replace("/","#")
        fname = fname.resolve()
        if not fname.exists():
            return _error("ref {} (p): file {} not found".format(refno, fname))
    elif format == 's':
        fname = _g.currentPath.parent / "si" / "{}.pdf".format(doi).replace("/","#")
        fname = fname.resolve()
        if not fname.exists():
            return _error("ref {} (s): file {} not found".format(refno, fname))
    elif format == 'w':
        fname = "https://doi.org/{}".format(doi)
    else:
        raise RuntimeError("AGH!!! _openDOIType() got an argument it shouldn't have!")

    # Open the thing, error out if it can't be found
    try:
        subprocess.run(["open", fname], check=True, capture_output=True)
    except subprocess.CalledProcessError:
        return _error("ref {}: file {} could not be opened".format(refno, fname))
    else:
        ec = _exitCode.SUCCESS
    return ec


#### Autosave and backup coroutines
async def _autosave():
    # Saves _g.articleList to _g.currentPath.swp if both are not empty
    interval = 2   # number of seconds between autosaves
    while True:
        try:
            await asyncio.sleep(interval)
            # Right now we only have one article list at a time, and
            #  changes_made just contains sentinel values.
            #  
            if _g.articleList != [] and _g.currentPath is not None and _g.changes > 0:
                write(_g.currentPath)
                print("autosaved")
                changes = 0
        except asyncio.CancelledError:
            break


async def _backup():
    # Saves _g.articleList to _g.currentPath.bak if it is not empty.
    # To be run once when entering the programme.
    if _g.articleList != [] and _g.currentPath is not None:
        try:
            await asyncio.sleep(0.1)
            backupFolder = _g.currentPath.parent / "backups"
            if not backupFolder.exists():
                backupFolder.mkdir()
            fname = backupFolder / (_g.currentPath.name + "date")
            write(fname, output="silent")
        except asyncio.CancelledError:
            return


#### Main coroutine
async def main():
    # STARTUP CODE
    # Try to load db.yaml from sys.argv[1], or current directory
    # In principle this should be done with argparse
    read(sys.argv[1:] if len(sys.argv) > 1 else [Path.cwd()])
    # Backup the current article list if it was found
    t_backup = asyncio.create_task(_backup())

    # MAIN TASKS
    autosave = True
    # Start autosave task.
    # It doesn't actually save unless there's something to save.
    if autosave:
        t_autosave = asyncio.create_task(_autosave())
    # Start REPL
    pmt = peepPrompt()
    pmtloop = await pmt.loop()

    print("Saving and exiting...")

    # SHUTDOWN CODE
    # Stop other tasks
    t_backup.cancel()
    t_autosave.cancel()
    # prompt_toolkit bug
    count = 0
    for t in asyncio.all_tasks():
        if "wait_for_timeout()" in repr(t):
            count += 1
            t.cancel()
    _debug("{} timeout tasks cancelled.".format(count))


if __name__ == "__main__":
    loop = asyncio.get_event_loop()
    loop.run_until_complete(main())
    loop.close()
