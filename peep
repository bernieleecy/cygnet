#!/usr/bin/env python3

import os
import sys
import subprocess
import asyncio
from copy import deepcopy
from pathlib import Path
from enum import Enum
from locale import getpreferredencoding
from datetime import datetime

import yaml
import prompt_toolkit as pt

import refMgmt
import listFmt
from constants import _g, _exitCode, timedeco, _error, _debug


class peepPrompt():
    style = pt.styles.Style.from_dict({
        "prompt": "{} italic".format(_g.ptPink),
        ""      : "{}".format(_g.ptGreen),
    })
    message = [("class:prompt", "peep > ")]
    session = pt.PromptSession()

    intro = "/------------------------------------------------------------\\" "\n"\
           f"| PeepLaTeX v{_g.version_number:<23}                         |"  "\n"\
            "| Common commands:                                           |"  "\n"\
            "| ----------------                                           |"  "\n"\
            "| r - read database     l - list papers     o - open a paper |"  "\n"\
            "| c - get a citation    h - help            q - quit         |"  "\n"\
            "\\------------------------------------------------------------/"

    async def loop(self):
        print(self.intro)
        with pt.patch_stdout.patch_stdout():
            while True:
                try:
                    line = await self.session.prompt_async(self.message,
                                                           style=self.style)
                except KeyboardInterrupt:
                    continue
                except EOFError:
                    break
                else:
                    x = line.split()
                    if not x:
                        continue
                    else:
                        cmd, args = x[0], x[1:]

                    if cmd in ["q", "quit"]:            # QUIT
                        break
                    elif cmd in ["o", "open"]:          # OPEN
                        openRef(args)
                    elif cmd in ["w", "write"]:         # WRITE
                        write(args)
                    elif cmd in ["l", "ls", "list"]:    # LIST
                        listArticles()
                    elif cmd in ["r", "read"]:          # READ
                        read(args)
                    elif cmd in ["h", "help"]:          # HELP
                        print(self.intro)
                    elif cmd in ["pee"]:                # PEE
                        print("zzzpeep")
                    elif cmd in ["peep"]:               # PEEP
                        print("PEEP!")
                    else:                               # unknown
                        _error("command '{}' not recognised".format(cmd))

                    # Need a tiny sleep to paper over a weird bug.
                    # Try removing this and spamming 'l' before quitting
                    #  to see the bug.
                    # There WILL be bugs if the time taken to print any
                    #  output (e.g. 'l' with large databases) exceeds
                    #  this sleep. With 3 references, printing takes a
                    #  fraction of a millisecond. With 300 references
                    #  it takes about 60 ms.
                    await asyncio.sleep(0.2)   # 200 ms.
        return


#############################################################################
#### Functions which (generally) parse prompt input, perform error checking,
#### and dispatch to specialised methods. Some are smart enough to be called
#### from outside the prompt, too.

@timedeco
def read(args=Path.cwd(), silent=False):
    """
    Reads a YAML file into the list of dictionaries _g.articleList.

    Accepts a string, pathlib.Path object, or a list/tuple containing
     a string or Path object as the first item.

    If the argument is a directory, then read() attempts to read from the
     file db.yaml inside that directory.

    Defaults to Path.cwd().
    """
    # Argument parsing
    if isinstance(args, (list, tuple)):
        try:
            args = args[0]
        except IndexError:   # empty list or tuple
            args = Path.cwd()
    try:
        p = Path(args)
    except TypeError:   # not castable
        return _error("invalid argument '{}' provided to read()".format(args))
    # If it points to an existing directory, load db.yaml from there
    if p.is_dir() and p.exists():
        p = p / "db.yaml"
    # Expand tildes and relative paths
    fname = p.expanduser().resolve()

    # If there is an article list loaded, save it first!
    if _g.articleList and _g.currentPath and _g.changes > 0:
        # list was loaded from somewhere
        write()
    elif _g.articleList and not _g.currentPath:
        # list was created from scratch
        return _error("current library has not been saved")

    # Check if the yaml file exists
    if not fname.exists():
        return _error("file {} not found".format(fname))

    # Read in the yaml file
    try:
        with open(fname, "r") as fp:
            if not silent:
                print("reading library {}... ".format(fname))
            _g.articleList = list(yaml.safe_load_all(fp))
            if not silent:
                print("read done")
    except FileNotFoundError:  # seems redundant, but ok
        return _error("file {} not found".format(fname))
    else:
        # Backup the new article list before doing anything, but only if
        #  it's really a new article...
        if fname != _g.currentPath:
            _g.currentPath = fname
            backup()

    return _exitCode.SUCCESS


@timedeco
def write(args=None, silent=False):
    """
    Writes the list of dictionaries _g.articleList to a YAML file.

    Accepts a string, pathlib.Path object, or a list/tuple containing
     a string or Path object as the first item.
    Defaults to _g.currentPath.
    """
    ### Argument parsing
    # Convert to a pathlib.Path object regardless of the input
    if isinstance(args, (list, tuple)):
        try:
            args = args[0]
        except IndexError:   # empty list or tuple
            args = _g.currentPath
    if args is None:
        args = _g.currentPath
    try:
        fname = Path(args)
    except TypeError:  # not castable
        return _error("invalid argument '{}' provided to write()".format(args))

    # Determine output location
    if fname.is_dir() and fname.exists():
        fname = fname / "db.yaml"

    # Write to the file
    try:
        with open(fname, "w") as fp:
            if not silent:
                print("writing current library to {}... ".format(fname))
            yaml.dump_all(_g.articleList, fp)
            if not silent:
                print("write done")
    except FileNotFoundError:
        return _error("directory {} does not exist".format(fname.parent))

    return _exitCode.SUCCESS


@timedeco
def listArticles(articles=None, type="long"):
    """
    Print prettified output of a given list of articles. Defaults to the entire
     list of articles _g.articleList.

    Accepts an additional parameter to control how many articles are printed.
     type="long": prints every article.
     type="short": prints first 2 and last 2.
    """
    # Make a copy first...
    l = deepcopy(articles) if articles is not None else deepcopy(_g.articleList)
    # Exit if an empty list is provided
    if l == []:
        print("no articles found")
        return

    # Get field sizes
    layout_str = "{0:<{1}}{2:{3}}{4:<{5}}{6:{7}}{8:{9}}"
    fss = listFmt.getFS(l)
    number_fs, author_fs, year_fs, journal_fs, title_fs = fss

    # Print header
    listFmt.printListHead(layout_str, fss)

    # Print all article contents
    if len(l) <= 4 or type == "long":
        for i, a in enumerate(l, start=1):
            listFmt.listOneArticle(i, a, layout_str, fss)
        return _exitCode.SUCCESS
    elif type == "short":
        n = len(l)
        listFmt.listOneArticle(1, l[0], layout_str, fss)
        listFmt.listOneArticle(2, l[1], layout_str, fss)
        listFmt.printDots(layout_str, fss)
        listFmt.listOneArticle(n - 1, l[n - 2], layout_str, fss)
        listFmt.listOneArticle(n, l[n - 1], layout_str, fss)
        return _exitCode.SUCCESS
    else:
        return _error("invalid type '{}' provided to listArticles")


@timedeco
def openRef(args):
    """
    Opens one or more references, in the form of PDF, SI, or Web.

    Takes a list of arguments.
    """
    if _g.articleList == []:
        return _error("no articles have been loaded")
    # Preprocess args, converting ["1", "2", "3", "p"] -> ["1,2,3,", "p"]
    argstr = ",".join(args)
    # Accept long forms
    argstr = argstr.replace("pdf","p").replace("si","s").replace("web","w")
    # Find the first character in argstr that isn't [0-9,-]
    x = next((i for i, c in enumerate(argstr) if c not in "1234567890,-"), len(argstr))
    # Then repackage them
    argRefno = argstr[:x].rstrip(",")
    argFormat = argstr[x:].replace(",","").strip()

    # Parse reference number(s)
    refnos = refMgmt.parseRefNo(argRefno)
    # Check the returned value
    ls = len(_g.articleList)
    if refnos is None or any(r > ls for r in refnos):
        return _error("invalid reference number(s) '{}' given".format(argRefno))
    # Parse format(s)
    if argFormat == "":
        formats = ['p']  # if no format specified, assume pdf
    else:
        formats = list(argFormat)
        # Check for invalid formats
        if any([i not in list("psw") for i in formats]):
            return _error("invalid format(s) '{}' given".format(argFormat))

    # Open the references
    dfs = ((_g.articleList[r - 1]["doi"], f) for r in refnos for f in formats)
    # open(1) is really fast, so it doesn't seem like this could be a problem unless we
    #  are opening tons and tons of references. But if it does then we may want to use
    #  some concurrency methods.
    for df in dfs:
        refMgmt.openDOIType(*df, _g.currentPath)
    return _exitCode.SUCCESS


@timedeco
def cite():
    pass


#############################################################################
#### Coroutine to autosave current list at regular intervals.

async def _autosave():
    # Saves _g.articleList to _g.currentPath if both are not empty
    while True:
        try:
            await asyncio.sleep(_g.autosaveInterval)
            # Right now we only have one article list at a time, and
            #  changes_made just contains sentinel values.
            if _g.articleList and _g.currentPath and _g.changes > 0:
                _debug("autosave: found {} change(s)".format(_g.changes))
                write(silent=True)
                _debug("autosave complete")
                changes = 0
        except asyncio.CancelledError:
            break

#############################################################################
#### Backup function.

def backup():
    """Saves _g.articleList (if it isn't empty) to the backups folder."""
    if _g.maxBackups == 0:
        return
    if _g.articleList != [] and _g.currentPath is not None:
        dbName = _g.currentPath.name
        # Figure out the folder name
        backupFolder = _g.currentPath.parent / "backups"
        if not backupFolder.exists():
            backupFolder.mkdir()
        # Clean up the folder if it's too cluttered
        # This sorts in descending order of time created
        oldBackups = sorted([i for i in backupFolder.iterdir()
                             if i.name.startswith(dbName)],
                            key=(lambda i: i.name),
                            reverse=True)
        # Deletes anything after the _g.maxBackups - 1 newest ones
        #  (because after we back up, there will be _g.maxBackups
        #  backups).
        if len(oldBackups) >= _g.maxBackups:
            for oldBackup in oldBackups[_g.maxBackups - 1:]:
                _debug("backup: deleting old backup {}".format(oldBackup))
                oldBackup.unlink()
        # Do the backup
        now = datetime.now().strftime(".%y%m%d_%H%M%S")
        fname = backupFolder / (dbName + now)
        write(fname, silent=True)
        _debug("backup: completed")
    else:
        _debug("backup: failed to back up articleList "
               "(length {}) with currentPath '{}'".format(len(_g.articleList),
                                                          _g.current))


#### Main coroutine
async def main():
    # STARTUP CODE
    # Try to load db.yaml from sys.argv[1], or current directory
    # In principle this should be done with argparse
    read(sys.argv[1:] if len(sys.argv) > 1 else [Path.cwd()])

    # MAIN TASKS
    autosave = True
    # Start autosave task.
    # It doesn't actually save unless there's something to save.
    if autosave:
        t_autosave = asyncio.create_task(_autosave())
    # Start REPL
    pmt = peepPrompt()
    pmtloop = await pmt.loop()

    print("Exiting... zzzpeep")

    # SHUTDOWN CODE
    # Stop other tasks
    t_autosave.cancel()
    # prompt_toolkit bug
    count = 0
    for t in asyncio.all_tasks():
        if "wait_for_timeout()" in repr(t):
            count += 1
            t.cancel()
    _debug("{} timeout tasks cancelled.".format(count))


if __name__ == "__main__":
    loop = asyncio.get_event_loop()
    loop.run_until_complete(main())
    loop.close()
