#!/usr/bin/env python3

import os
import sys
import subprocess
import asyncio
from pathlib import Path
from copy import deepcopy
from enum import Enum
from datetime import datetime
from tempfile import NamedTemporaryFile

import yaml
import prompt_toolkit as pt

import refMgmt
import listFmt
from constants import _g, _p, _exitCode, _timedeco, _error, _debug, _copy


class peepPrompt():
    style = pt.styles.Style.from_dict({
        "prompt": "{} italic".format(_g.ptPink),
        ""      : "{}".format(_g.ptGreen),
    })
    message = [("class:prompt", "peep > ")]
    commentSymbol = '#'
    session = pt.PromptSession()

    intro = "/------------------------------------------------------------\\" "\n"\
           f"| PeepLaTeX v{_g.version_number:<23}                         |"  "\n"\
            "| Common commands:                                           |"  "\n"\
            "| ----------------                                           |"  "\n"\
            "| r - read database     l - list papers     o - open a paper |"  "\n"\
            "| c - get a citation    h - help            q - quit         |"  "\n"\
            "\\------------------------------------------------------------/"

    async def loop(self):
        print(self.intro)
        with pt.patch_stdout.patch_stdout():
            while True:
                try:
                    line = await self.session.prompt_async(self.message,
                                                           style=self.style)
                except KeyboardInterrupt:
                    continue
                except EOFError:
                    break
                else:
                    # Remove anything after a comment
                    if self.commentSymbol in line:
                        line = line.split(self.commentSymbol)[0].rstrip()
                    line = line.split()
                    if not line:
                        continue
                    else:
                        cmd, args = line[0], line[1:]
                    cmd = cmd.lstrip(":")  # I have typed in :q more than once

                    # If any numbers are in the cmd, separate the bit with 
                    #  a number and prepend it to args. This allows us to do
                    #  things like "o1" instead of "o 1". Yes I'm lazy.
                    n = next((i for i, c in enumerate(cmd) if c.isdigit()), len(cmd))
                    if n < len(cmd):
                        args = [cmd[n:]] + args
                        cmd = cmd[:n]

                    if cmd in ["q", "quit", "zzzpeep"]:         # QUIT
                        break
                    elif cmd in ["c", "cite"]:                  # CITE
                        asyncio.create_task(cite(args))
                    elif cmd in ["o", "open"]:                  # OPEN
                        openRef(args)
                    elif cmd in ["w", "write"]:                 # WRITE
                        write(args)
                    elif cmd in ["l", "ls", "list"]:            # LIST
                        listArticles()
                    elif cmd in ["r", "read"]:                  # READ
                        read(args)
                    elif cmd in ["e", "edit"]:                  # EDIT
                        editRef(args)
                    elif cmd in ["a", "add"]:                   # ADD
                        addRef(args)
                    elif cmd in ["d", "del", "delete"]:         # DELETE
                        await deleteRef(args)
                    elif cmd in ["u", "up", "update"]:          # UPDATE
                        await updateRef(args)
                    elif cmd in ["h", "help"]:                  # HELP
                        print(self.intro)
                    elif cmd in ["pee"]:                        # PEE
                        print("zzzpee...")
                    elif cmd in ["peep", "PEEP"]:               # PEEP
                        print("PEEP!")
                    else:                                       # unknown
                        _error("command '{}' not recognised".format(cmd))

                    # Need a tiny sleep to paper over a weird bug.
                    # Try removing this and spamming 'l' before quitting
                    #  to see the bug.
                    # There WILL be bugs if the time taken to print any
                    #  output (e.g. 'l' with large databases) exceeds
                    #  this sleep. With 3 references, printing takes a
                    #  fraction of a millisecond. With 300 references
                    #  it takes about 60 ms.
                    await asyncio.sleep(0.1)   # 100 ms.
        return


#############################################################################
#### Functions which (generally) parse prompt input, perform error checking,
#### and dispatch to specialised methods. Some are smart enough to be called
#### from outside the prompt, too.

@_timedeco
def read(args=Path.cwd(), silent=False):
    """
    Reads a YAML file into the list of dictionaries _g.articleList.

    Accepts a string, pathlib.Path object, or a list/tuple containing
     a string or Path object as the first item.

    If the argument is a directory, then read() attempts to read from the
     file db.yaml inside that directory.

    Defaults to Path.cwd().
    """
    # Argument parsing
    if isinstance(args, (list, tuple)):
        try:
            args = args[0]
        except IndexError:   # empty list or tuple
            args = Path.cwd()
    try:
        p = Path(args)
    except TypeError:   # not castable
        return _error("read: invalid argument '{}'".format(args))
    # If it points to an existing directory, load db.yaml from there
    if p.is_dir() and p.exists():
        p = p / "db.yaml"
    # Expand tildes and relative paths
    fname = p.expanduser().resolve()

    # If there is an article list loaded, save it first!
    if _g.articleList and _g.currentPath and _g.changes > 0:
        # list was loaded from somewhere
        write()
    elif _g.articleList and not _g.currentPath:
        # list was created from scratch
        return _error("read: current library has not been saved, cannot read a new list")

    # Check if the yaml file exists
    if not fname.exists():
        return _error("read: file {} not found".format(fname))

    # Read in the yaml file
    try:
        with open(fname, "r") as fp:
            if not silent:
                print("read: reading library {}... ".format(fname))
            try:
                _g.articleList = list(yaml.safe_load_all(fp))
            except yaml.YAMLError:
                return _error("read: invalid YAML file {}".format(fname))
            if not silent:
                print("read: done")
    except FileNotFoundError:  # seems redundant, but ok
        return _error("read: file {} not found".format(fname))
    else:
        # Backup the new article list before doing anything, but only if
        #  it's really a new article...
        if fname != _g.currentPath:
            _g.currentPath = fname
            backup()

    return _exitCode.SUCCESS


@_timedeco
def write(args=None, silent=False):
    """
    Writes the list of dictionaries _g.articleList to a YAML file.

    Accepts a string, pathlib.Path object, or a list/tuple containing
     a string or Path object as the first item.
    Defaults to _g.currentPath.
    """
    ### Argument parsing
    # Convert to a pathlib.Path object regardless of the input
    if isinstance(args, (list, tuple)):
        try:
            args = args[0]
        except IndexError:   # empty list or tuple
            args = _g.currentPath
    if args is None:
        args = _g.currentPath
    try:
        fname = Path(args)
    except TypeError:  # not castable
        return _error("write: invalid argument '{}'".format(args))

    # Determine output location
    if fname.is_dir() and fname.exists():
        fname = fname / "db.yaml"

    # Write to the file
    try:
        with open(fname, "w") as fp:
            if not silent:
                print("write: writing current library to {}... ".format(fname))
            yaml.dump_all(_g.articleList, fp)
            if not silent:
                print("write: done")
    except FileNotFoundError:
        return _error("write: directory {} does not exist".format(fname.parent))

    return _exitCode.SUCCESS


@_timedeco
def listArticles(articles=None, type="long"):
    """
    Print prettified output of a given list of articles. Defaults to the entire
     list of articles _g.articleList.

    Accepts an additional parameter to control how many articles are printed.
     type="long": prints every article.
     type="short": prints first 2 and last 2.
    """
    # Make a copy first...
    l = deepcopy(articles) if articles is not None else deepcopy(_g.articleList)
    # Exit if an empty list is provided
    if l == []:
        print("no articles found")
        return

    # Get field sizes
    layout_str = "{0:<{1}}{2:{3}}{4:<{5}}{6:{7}}{8:{9}}"
    fss = listFmt.getFS(l)
    number_fs, author_fs, year_fs, journal_fs, title_fs = fss

    # Print header
    listFmt.printListHead(layout_str, fss)

    # Print all article contents
    if len(l) <= 4 or type == "long":
        for i, a in enumerate(l, start=1):
            listFmt.listOneArticle(i, a, layout_str, fss)
        return _exitCode.SUCCESS
    elif type == "short":
        n = len(l)
        listFmt.listOneArticle(1, l[0], layout_str, fss)
        listFmt.listOneArticle(2, l[1], layout_str, fss)
        listFmt.printDots(layout_str, fss)
        listFmt.listOneArticle(n - 1, l[n - 2], layout_str, fss)
        listFmt.listOneArticle(n, l[n - 1], layout_str, fss)
        return _exitCode.SUCCESS
    else:
        return _error("listArticles: invalid type '{}'".format(type))


@_timedeco
def openRef(args):
    """
    Opens one or more references, in the form of PDF, SI, or Web.

    Takes a list of arguments.
    """
    if _g.articleList == []:
        return _error("openRef: no articles have been loaded")
    if args == []:
        return _error("openRef: no references selected")
    # Process args
    abbrevs = {"p": "pdf",
               "s": "si",
               "w": "web"}
    refnos, formats = refMgmt.parseRefnoFormat(args, abbrevs=abbrevs)

    # Check the returned values
    ls = len(_g.articleList)
    if refnos is None or refnos == [] or any(r > ls for r in refnos) \
            or formats is None or any(f not in abbrevs for f in formats):
        return _error("openRef: invalid argument{} '{}' given".format(_p(args),
                                                                      " ".join(args)))
    # Default format
    if formats == []:
        formats = ['p']

    # Open the references
    drfs = ((_g.articleList[r - 1]["doi"], r, f) for r in refnos for f in formats)
    # open(1) is really fast, so it doesn't seem like this could be a problem unless we
    #  are opening tons and tons of references. But if it does then we may want to use
    #  some concurrency methods.
    for drf in drfs:
        refMgmt.openDOIType(*drf, _g.currentPath)
    return _exitCode.SUCCESS


@_timedeco
async def cite(args):
    """Prints citation for one or more references in the form of DOI, BibLaTeX, or
    Markdown (e.g. for use on Stack Exchange).

    Also copies the citation text to system clipboard.
    """
    if _g.articleList == []:
        return _error("cite: no articles have been loaded")
    if args == []:
        return _error("cite: no references selected")
    # Process args
    abbrevs = {"d": "doi",
               "b": "bib",
               "m": "md",
               "M": "MD"}
    refnos, formats = refMgmt.parseRefnoFormat(args, abbrevs=abbrevs)

    # Check the returned values
    ls = len(_g.articleList)
    if refnos is None or refnos == [] or any(r > ls for r in refnos) \
            or formats is None or any(f not in abbrevs for f in formats):
        return _error("cite: invalid argument{} '{}' given".format(_p(args),
                                                                   " ".join(args)))
    # Default format = biblatex
    if formats == []:
        formats = ['b']

    sep = ""  # Need a newline between citations if there is more than one.
    afs = ((_g.articleList[r - 1], f) for r in refnos for f in formats)
    citation = ""
    for af in afs:
        citation += sep
        citation += refMgmt.makeCitation(*af)
        if len(refnos) > 1 or len(formats) > 1:
            sep = "\n\n" if af[1] in "bMm" else "\n"
    print(citation)
    await _copy(citation)


@_timedeco
def editRef(args):
    """Edits one or more references using vim."""
    if _g.articleList == []:
        return _error("editRef: no articles have been loaded")
    if args == []:
        return _error("editRef: no references selected")

    # no formats to process; just refnos
    refnos = refMgmt.parseRefno(",".join(args))
    # Check the returned values
    ls = len(_g.articleList)
    if refnos is None or refnos == [] or any(r > ls for r in refnos):
        return _error("editRef: invalid argument{} '{}' given".format(_p(args),
                                                                      " ".join(args)))

    # Construct the initial message
    articlesToEdit = []
    for r in refnos:
        articlesToEdit.append(deepcopy(_g.articleList[r - 1]))
    # Create and write data to temp file.
    # Suffix is needed so that vim syntax highlighting is enabled. :)
    fname = NamedTemporaryFile(suffix=".yaml").name
    with open(fname, 'wb') as fp:
        yaml.dump_all(articlesToEdit, fp, encoding=_g.gpe)
    # Open the file in vim. Vim's stdin and stdout need to be from/to a terminal.
    # This is already the case for stdin, but we need to set stdout manually.
    try:
        subprocess.run(["vim", fname], stdout=open('/dev/tty', 'wb'), check=True)
    except subprocess.CalledProcessError:   # e.g. :cq
        return _error("editRef: vim quit unexpectedly; no changes made")
    else:
        # Put the edited metadata back in the article list. If changes have been 
        #  made, increment _g.changes to trigger autosave.
        with open(fname, "r") as fp:
            try:
                editedArticles = list(yaml.safe_load_all(fp))
            except yaml.YAMLError:
                return _error("editRef: invalid YAML syntax")
            for (a, r) in zip(editedArticles, refnos):
                if _g.articleList[r - 1] != a:
                    _g.articleList[r - 1] = deepcopy(a)
                    _g.changes += 1
        return _exitCode.SUCCESS


@_timedeco
def addRef(args):
    """Adds one or more references (passed as DOIs) to the article list."""
    if args == []:
        return _error("addRef: no DOIs provided")
    yes = 0
    no = 0
    for doi in args:
        # Check if it's already in the library
        found = False
        for r, art in enumerate(_g.articleList, start=1):
            if doi == art["doi"]:
                _error("addRef: DOI '{}' already in library.\n".format(doi) + \
                       "               Use 'u[pdate] {}' to refresh metadata.".format(r))
                no += 1
                found = True
                break
        if found:
            continue
        # Otherwise, proceed to get the data
        a = refMgmt.getMetadataFromDOI(doi)
        if a is None:
            _error("addRef: invalid DOI '{}'".format(doi))
            no += 1
            continue
        else:
            print("addRef: added DOI '{}'".format(doi))
            print(a)
            yes += 1
            _g.articleList.append(a)
    print("addRef: {} DOIs added, {} failed".format(yes, no))
    _g.changes += yes


@_timedeco
async def updateRef(args):
    """Update one or more references using the Crossref API.
    For each reference, prompts the user as to whether they want to update."""
    if _g.articleList == []:
        return _error("updateRef: no articles have been loaded")
    if args == []:
        return _error("updateRef: no references selected")

    # no formats to process; just refnos
    refnos = refMgmt.parseRefno(",".join(args))
    # Check the returned values
    ls = len(_g.articleList)
    if refnos is None or refnos == [] or any(r > ls for r in refnos):
        return _error("updateRef: invalid argument{} '{}' given".format(_p(args),
                                                                        " ".join(args)))

    # potentially lots of HTTP requests! can we do this asynchronously?
    for r in refnos:
        yes = 0
        aold = _g.articleList[r - 1]
        anew = refMgmt.getMetadataFromDOI(aold["doi"])
        if anew is None:
            _error("updateRef: ref {} has an invalid DOI '{}'".format(r, aold["doi"]))
        ndiffs = refMgmt.diffArticles(aold, anew)
        if ndiffs == 0:
            print("updateRef: no new data for ref {} found on Crossref".format(r))
        else:
            # Must use a new PromptSession().prompt_async(), otherwise it gets messed up.
            msg = "updateRef: accept new data for ref {} (y/n)? ".format(r)
            style = pt.styles.Style.from_dict({"prompt": "{}".format(_g.ptBlue)})
            try:
                ans = await pt.PromptSession().prompt_async(msg, style=style)
            except (EOFError, KeyboardInterrupt):
                ans = "no"
            if ans.strip().lower() in ["", "y", "yes"]:
                _g.articleList[r - 1] = anew
                print("updateRef: successfully updated ref {}".format(r))
                yes += 1
            else:  # ok, it isn't really (y/n), it's (y/not y)
                print("updateRef: rejected changes for ref {}".format(r))
    print("updateRef: {} article{} updated".format(yes, _p(yes)))
    _g.changes += yes
    return _exitCode.SUCCESS


@_timedeco
async def deleteRef(args):
    """Delete one or more references."""
    if _g.articleList == []:
        return _error("deleteRef: no articles have been loaded")
    if args == []:
        return _error("deleteRef: no references selected")

    # no formats to process; just refnos
    refnos = refMgmt.parseRefno(",".join(args))
    # Check the returned values
    ls = len(_g.articleList)
    if refnos is None or refnos == [] or any(r > ls for r in refnos):
        return _error("deleteRef: invalid argument{} '{}' given".format(_p(args),
                                                                        " ".join(args)))

    # Must use a new PromptSession().prompt_async(), otherwise it gets messed up.
    yes = 0
    msg = "deleteRef: really delete ref{} {} (y/n)? ".format(_p(refnos),
                                                             ", ".join(str(r) for r in refnos))
    style = pt.styles.Style.from_dict({"prompt": "{}".format(_g.ptBlue)})
    try:
        ans = await pt.PromptSession().prompt_async(msg, style=style)
    except (EOFError, KeyboardInterrupt):
        ans = "no"
    if ans.strip().lower() in ["", "y", "yes"]:
        # Must sort the list in descending order so that you don't get earlier
        #  deletions affecting later ones!!
        for r in sorted(refnos, reverse=True):
            del _g.articleList[r - 1]
            yes += 1
        print("deleteRef: {} ref{} deleted".format(yes, _p(yes)))
        _g.changes += yes
    else:
        print("deleteRef: no refs deleted")
    return _exitCode.SUCCESS


#############################################################################
#### Coroutine to autosave current list at regular intervals.

async def _autosave():
    # Saves _g.articleList to _g.currentPath if changes have been made.
    while True:
        try:
            await asyncio.sleep(_g.autosaveInterval)
            # Right now we only have one article list at a time, and
            #  changes just contains sentinel values.
            if _g.articleList and _g.currentPath and _g.changes > 0:
                _debug("autosave: found {} change".format(_g.changes, _p(_g.changes)))
                write(silent=True)
                _debug("autosave complete")
                _g.changes = 0
        except asyncio.CancelledError:
            break

#############################################################################
#### Backup function.

def backup():
    """Saves _g.articleList (if it isn't empty) to the backups folder."""
    if _g.maxBackups == 0:
        return
    if _g.articleList != [] and _g.currentPath is not None:
        dbName = _g.currentPath.name
        # Figure out the folder name
        backupFolder = _g.currentPath.parent / "backups"
        if not backupFolder.exists():
            backupFolder.mkdir()
        # Clean up the folder if it's too cluttered
        # This sorts in descending order of time created
        oldBackups = sorted([i for i in backupFolder.iterdir()
                             if i.name.startswith(dbName)],
                            key=(lambda i: i.name),
                            reverse=True)
        # Deletes anything after the _g.maxBackups - 1 newest ones
        #  (because after we back up, there will be _g.maxBackups
        #  backups).
        if len(oldBackups) >= _g.maxBackups:
            for oldBackup in oldBackups[_g.maxBackups - 1:]:
                _debug("backup: deleting old backup {}".format(oldBackup))
                oldBackup.unlink()
        # Do the backup
        now = datetime.now().strftime(".%y%m%d_%H%M%S")
        fname = backupFolder / (dbName + now)
        write(fname, silent=True)
        _debug("backup: completed")
    else:
        _debug("backup: failed to back up articleList "
               "(length {}) with currentPath '{}'".format(len(_g.articleList),
                                                          _g.current))


#### Main coroutine
async def main():
    # STARTUP CODE
    # Try to load db.yaml from sys.argv[1], or current directory
    # In principle this should be done with argparse
    read(sys.argv[1:] if len(sys.argv) > 1 else [Path.cwd()])

    # MAIN TASKS
    autosave = True
    # Start autosave task.
    # It doesn't actually save unless there's something to save.
    if autosave:
        t_autosave = asyncio.create_task(_autosave())
    # Start REPL
    pmt = peepPrompt()
    pmtloop = await pmt.loop()

    print("Exiting... zzzpeep")

    # SHUTDOWN CODE
    # Stop other tasks
    t_autosave.cancel()
    # prompt_toolkit bug
    count = 0
    for t in asyncio.all_tasks():
        if "wait_for_timeout()" in repr(t):
            count += 1
            t.cancel()
    _debug("{} timeout tasks cancelled.".format(count))


if __name__ == "__main__":
    loop = asyncio.get_event_loop()
    loop.run_until_complete(main())
    loop.close()
