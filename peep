#!/usr/bin/env python3

import os
import sys
import subprocess
import cmd
import atexit
from time import time, sleep
from threading import Thread
from copy import deepcopy
from pathlib import Path
from enum import Enum
from locale import getpreferredencoding
from functools import wraps

import yaml
from crossref.restful import Works, Etiquette

version_number = "0.1"

my_etiquette = Etiquette('PeepLaTeX',
                         version_number,
                         'https://github.com/yongrenjie',
                         'yongrenjie@gmail.com')
article_list = []
last_list = []
current_db_path = None     # Path object pointing to the current database
command_history = []


class ExitCode(Enum):
    SUCCESS = 0
    FAILURE = 1
    WAITING = 2
    pass


def timedeco(fn):
    """
    Decorator which prints time elapsed for a function call.
    """
    @wraps(fn)
    def timer(*args, **kwargs):
        now = time()
        rval = fn(*args, **kwargs)
        print("time elapsed: {:.3f} ms".format((time() - now) * 1000))
        return rval
    return timer


class peepShell(cmd.Cmd):
    """
    Command-line interface.
    """
    intro = "/---------------------------------------------------------------\\" "\n"\
           f"| PeepLaTeX v{version_number:<20}                               |"  "\n"\
            "| Common commands:                                              |"  "\n"\
            "| ----------------                                              |"  "\n"\
            "| r - read database     l - list papers        o - open a paper |"  "\n"\
            "| c - get a citation    h - print this again   q - quit         |"  "\n"\
            "\\---------------------------------------------------------------/"
    prompt = "peep > "

    def default(self, line):
        wrongCmd = line.split()[0]
        _error("command '{}' unrecognised".format(wrongCmd))

    def emptyline(self):
        # do nothing
        pass

    # Functions
    def do_q(self, arg):       # QUIT
        """
        Quit.
        """
        sys.exit(0)

    def do_EOF(self, arg):     # QUIT alternative
        print()
        sys.exit(0)

    def do_h(self, arg):       # HELP
        """
        Print help.
        """
        print(self.intro)

    def do_r(self, arg):       # READ 
        """
        Reads in a YAML file.
        Usage: r [fname]
          [fname]: absolute or relative path to the desired input file.
        """
        read(arg.split())

    def do_w(self, arg):       # WRITE
        """
        Write to a YAML file.
        Usage: w [fname]
          [fname]: absolute or relative path to the desired output file.
        """
        write(arg.split())

    def do_l(self, arg):       # LIST
        """
        Lists all available articles.
        Any arguments are discarded. (For now.)
        """
        global article_list
        listArticles(article_list)

    def do_o(self, arg):       # OPEN
        """
        Opens one or more references in the form of PDF, SI, or Web.
        Usage: o [refno] [format]
          [refno]: integer, or range of integers X-Y (inclusive). Multiple refnos can
                   be concatenated with commas or spaces.
          [format]: "p", "s", or "w". Multiple formats can be concatenated directly,
                   with commas, or with spaces. Defaults to "p" if not specified.
        """
        openRef(arg.split())

    # debugging tests
    def do_sleep(self, arg):
        Thread(target=zzzsleep, args=(arg.split()[0],)).start()
    def do_check(self, arg):
        print(article_list)


@timedeco
def read(argls):
    """
    Reads a YAML file into the list of dictionaries article_list.

    Takes a list as an argument. The first element of this list must be an
     (absolute or relative) path to the folder containing a db.yaml file,
     or an (absolute or relative) path to a .yaml / .yml file. If the list is
     empty, then it is taken to be the current working directory.

    Any other elements in the list are ignored.
    """
    global article_list
    global current_db_path

    # Get the directory from argls, converting to pathlib.Path
    try:
        p = Path(argls[0])
    except IndexError:
        p = Path.cwd()
    # If it points to an existing directory, load db.yaml from there
    if p.is_dir() and p.exists():
        p = p / "db.yaml"
    # Expand tildes and relative paths
    fname = p.expanduser().resolve()
    # Check if the yaml file exists
    if not fname.exists():
        return _error("file {} not found".format(fname))

    # Read in the yaml file
    try:
        with open(fname, "r") as fp:
            print("Loading library {}... ".format(fname), end="", flush=True)
            article_list = list(yaml.safe_load_all(fp))
            print("done")
    except FileNotFoundError:  # seems redundant, but ok
        return _error("file {} not found".format(fname))
    else:
        current_db_path = fname
        return ExitCode.SUCCESS


@timedeco
def write(argls):
    """
    Writes the list of dictionaries article_list to a YAML file.
    """
    try:
        fname = Path(argls[0]).expanduser().resolve()
    except IndexError:
        if current_db_path is not None:
            fname = current_db_path
        else:
            return _error("no file specified for writing")
    try:
        with open(fname, "w") as fp:
            yaml.dump_all(article_list, fp)
    except FileNotFoundError:
        return _error("directory {} does not exist".format(fname.parent))
    return ExitCode.SUCCESS


@timedeco
def listArticles(articles, type="long"):
    """
    Print prettified output of a given list of articles.
     type="long": prints every article.
     type="short": prints first 2 and last 2.
    """
    # Exit if article list is empty
    if articles == []:
        print("no articles found")
        return
    # Make a copy first...
    l = deepcopy(articles)

    # Get field sizes
    layout_str = "{0:<{1}}{2:{3}}{4:<{5}}{6:{7}}{8:{9}}"
    fss = _getFS(l)
    number_fs, author_fs, year_fs, journal_fs, title_fs = fss

    # Print header
    _printListHead(layout_str, fss)

    # Print all article contents
    if len(l) <= 4 or type == "long":
        for i, a in enumerate(l, start=1):
            _listOneArticle(i, a, layout_str, fss)
        return ExitCode.SUCCESS
    elif type == "short":
        n = len(l)
        _listOneArticle(1, l[0], layout_str, fss)
        _listOneArticle(2, l[1], layout_str, fss)
        _printDots(layout_str, fss)
        _listOneArticle(n - 1, l[n - 2], layout_str, fss)
        _listOneArticle(n, l[n - 1], layout_str, fss)
        return ExitCode.SUCCESS
    else:
        raise RuntimeError("ARGHH!")


@timedeco
def openRef(argls):
    """
    Opens one or more references, in the form of PDF, SI, or Web.
    """
    global article_list
    global current_db_path
    # Preprocess argls, converting ["1", "2", "3", "p"] -> ["1,2,3,", "p"]
    argstr = ",".join(argls)
    # Find the first character in argstr that isn't [0-9,-]
    x = next((i for i, c in enumerate(argstr) if c not in "1234567890,-"), len(argstr))
    # Then repackage them
    argRefno = argstr[:x].rstrip(",")
    argFormat = argstr[x:].replace(",","")

    # Parse reference number(s)
    try:
        refnos = _parseRefNo(argRefno)
    except IndexError:
        return _error("no reference number given")
    else:
        # Check the returned value
        ls = len(article_list)
        if refnos is None or any(r > ls for r in refnos):
            return _error("invalid reference number(s) '{}' given".format(argRefno))
    # Parse format(s)
    try:
        formats = list(argFormat)
    except IndexError:
        formats = ['p']  # if no format specified, assume pdf
    else:
        # Check for invalid formats
        if any([i not in list("psw") for i in formats]):
            return _error("invalid format(s) '{}' given".format(argFormat))

    # Open the references
    # generator object
    rfs = ((r, f) for r in refnos for f in formats)
    # open(1) is really fast, so it doesn't seem like this could be a problem unless we
    #  are opening tons and tons of references. But if it does then we may want to use
    #  some concurrency methods.
    for rf in rfs:
        _openDOIType(*rf)


#### Tools for debugging

@timedeco
def zzzsleep(time):
    """
    For debugging purposes
    """
    t = float(time)
    print("going to zzz for {} seconds...".format(t))
    sleep(t)
    print("\nzzz... woke up... exiting\n")


#### Internal tool for error reporting

def _error(msg):
    """
    Generic error printer.
    """
    print("error: {}".format(msg))
    return ExitCode.FAILURE


#### Internal tools for list printing

def _printListHead(layout_str, fss):
    """
    Print the header.
    """
    # unpack field sizes
    number_fs, author_fs, year_fs, journal_fs, title_fs = fss
    # blank row
    print()
    # header row
    print(layout_str.format("#", number_fs,
                            "Authors", author_fs,
                            "Year", year_fs,
                            "Journal", journal_fs,
                            "Title & DOI", title_fs))
    # a horizontal line
    print("-" * (number_fs + author_fs + year_fs + journal_fs + title_fs))


def _listOneArticle(i, a, layout_str, fss):
    """
    Print one article.
     i          - the number in front.
     a          - the article
     layout_str - the format string.
     fss        - tuple of field sizes: (number, author, year, journal, title)
    """
    # unpack field sizes
    number_fs, author_fs, year_fs, journal_fs, title_fs = fss
    # generate volume info
    volinfo = _fmtVolInfo(a)
    # print the first round of information
    first_author = a["authors"].pop(0)
    print(layout_str.format(i, number_fs,
                            _fmtAuthor(first_author, style="display"), author_fs,
                            a["year"], year_fs,
                            a["journal_short"].replace(".",""), journal_fs,
                            a["title"][:title_fs], title_fs))
    # cut off the first author
    a["title"] = a["title"][title_fs:]
    # if there is still information to be printed, print it
    while any([a["authors"] != [],
               a["title"] != "",
               a["doi"] != "",
               volinfo != ""]):
        # get an author if there is one
        try:
            next_author = a["authors"].pop(0)
        except IndexError:
            next_author = ""
        # replace the title with the DOI if the title has been printed and DOI hasn't
        if a["title"] == "" and a["doi"] != "":
            a["title"] = a["doi"]
            a["doi"] = ""
        print(layout_str.format("", number_fs,
                                _fmtAuthor(next_author, style="display"), author_fs,
                                "", year_fs,
                                volinfo, journal_fs,
                                a["title"][:title_fs], title_fs))
        a["title"] = a["title"][title_fs:]
        volinfo = ""
    # empty line (for readability?)
    print()


def _printDots(layout_str, fss):
    """
    Prints dots.
    """
    # unpack field sizes
    number_fs, author_fs, year_fs, journal_fs, title_fs = fss
    # header row
    print(layout_str.format("...", number_fs,
                            "...", author_fs,
                            "...", year_fs,
                            "...", journal_fs,
                            "...", title_fs))
    print()


def _getFS(l):
    """
    Calculates appropriate field sizes for the list output.

    I tried caching this information in the article entry, but it makes virtually zero
     difference to the runtime even for a library of 1400 articles, and it adds extra time
     for reading/writing from/to disk (for reading in 1400 articles, the time taken increased
     from ca 2.4 -> 2.7 seconds).
    It's also a mess, because that means you'd have to remember to cache the information every
     time you change the metadata.
    Unfortunately you also can't use functools.lru_cache with this, because in general it will
     expect a dictionary as the argument, which isn't hashable.
    """
    spaces = 2
    number_fs = len(str(len(l))) + spaces
    author_fs = max(max(max(len(_fmtAuthor(auth, style="display")) for auth in art["authors"]) for art in l),
                    len("Authors")
                    ) + spaces
    year_fs = 4 + spaces
    journal_fs = max(max(len(art["journal_short"].replace(".","")) for art in l),
                     max(len(_fmtVolInfo(art)) for art in l),
                     len("Journal info")
                     ) + spaces
    # either use up the remaining space, or extend to the end of the longest title
    total_columns = os.get_terminal_size().columns
    title_fs = min(total_columns - number_fs - author_fs - year_fs - journal_fs,
                   max(len(a["title"]) for a in l))

    return (number_fs, author_fs, year_fs, journal_fs, title_fs)


def _fmtAuthor(author, style):
    """
    Prettify author names.
    """
    # Return empty string for any Falsy value
    if not author:
        return ""
    family_name = author["family"]
    given_names = author["given"]
    # Jonathan R. J. Yong -> JRJ Yong
    if style == "display":
        return "".join(n[0] for n in given_names.split()) + " " + author["family"]
    # Otherwise just return the name as a string
    else:
        return given_names + " " + family_name


def _fmtVolInfo(article):
    """
    Returns the string "vol (issue), page-page", or "vol, page-page" if
    no issue number is present.
    """
    if "issue" in article:
        return "{} ({}), {}".format(article["volume"],
                                    article["issue"],
                                    article["page"])
    else:
        return "{}, {}".format(article["volume"],
                               article["page"])


#### Internal tools for reference number parsing

def _parseRefNo(s):
    """
    Takes a string s and returns a list of int reference numbers.
    Returns None if any error is found.
     e.g. "1"      -> [1]
          "1-5"    -> [1, 2, 3, 4, 5]
          "1-4,43" -> [1, 2, 3, 4, 43]
    """
    s = s.split(",")
    t = []
    try:
        for i in s:
            if "-" in i:
                min, max = i.split("-")   # ValueError if too many entries
                if min >= max:
                    raise ValueError("you silly billy")
                for m in range(int(min), int(max) + 1):
                    t.append(m)
            else:
                t.append(int(i))          # ValueError if not castable to int
    except ValueError:
        return None
    else:
        return t


#### Internal tool for opening PDFs / DOI URLs

def _openDOIType(refno, format):
    global article_list

    # Get the doi
    try:
        doi = article_list[refno - 1]["doi"]
    except IndexError:
        raise RuntimeError("AGH!!! _openDOIType() got an argument it shouldn't have!")

    # Get the link to the pdf / website
    if format == 'p':
        fname = current_db_path.parent / "pdf" / "{}.pdf".format(doi).replace("/","#")
        fname = fname.resolve()
        if not fname.exists():
            return _error("ref {} (p): file {} not found".format(refno, fname))
    elif format == 's':
        fname = current_db_path.parent / "si" / "{}.pdf".format(doi).replace("/","#")
        fname = fname.resolve()
        if not fname.exists():
            return _error("ref {} (s): file {} not found".format(refno, fname))
    elif format == 'w':
        fname = "https://doi.org/{}".format(doi)
    else:
        raise RuntimeError("AGH!!! _openDOIType() got an argument it shouldn't have!")

    # Open the thing, error out if it can't be found
    try:
        subprocess.run(["open", fname], check=True, capture_output=True)
    except subprocess.CalledProcessError:
        return _error("ref {}: file {} could not be opened".format(refno, fname))
    else:
        ec = ExitCode.SUCCESS
    return ec


#### Main routines

def main():
    # Try to load db.yaml from sys.argv[1], or current directory
    # In principle this should be done with argparse
    global article_list
    read(sys.argv[1:] if len(sys.argv) > 1 else [Path.cwd()])
    # Start the REPL
    peepShell().cmdloop()


if __name__ == "__main__":
    main()
